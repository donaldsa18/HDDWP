#ifndef GENERALSOLVER
#define GENERALSOLVER

#include <string>
#include <vector>
#include <iostream>

//JAVA TO C++ CONVERTER NOTE: Forward class declarations:
class MagicSquareState;

/// <summary>
/// Contains a set of functions for solving incomplete Magic Squares
/// 
/// @author Anthony Donaldson
/// @author Phillip Manalili-Simeon
/// </summary>

using boost::optional<int>;

class GeneralSolver
{

	static void main(std::string args[]) throw(FileNotFoundException);

	/// <summary>
	/// Returns a solved MagicSquareState or null if none exists
	/// </summary>
	/// <param name="sq">  The starting MagicSquareState with numbers missing </param>
	/// <returns>     Returns a solved MagicSquareState or null if none exists </returns>
public:
	virtual MagicSquareState *checkPossibilities(MagicSquareState *sq);

	/// <summary>
	/// Returns a 2D ArrayList of Integers containing all
	/// of the combinations of the input list
	/// </summary>
	/// <param name="nums">  The starting MagicSquareState with numbers missing </param>
	/// <returns>     Returns a solved MagicSquareState or null if none exists </returns>
	static std::vector<std::vector<int>> tryAllComb(std::vector<int> &nums, int length);

	/// <summary>
	/// Finds all possible solutions to the subset sum problem
	/// and stores the answer in a HashSet
	/// </summary>
	/// <param name="set"> 			an int array with all the numbers in the set in question </param>
	/// <param name="tup"> 			the int array already included from the set </param>
	/// <param name="tupMaxSize"> 	the length of the tuple  being used currently </param>
	/// <param name="sum">			the current sum of the elements in the tuple </param>
	/// <param name="ite">			set to 0 when calling initially </param>
	/// <param name="target">		the target sum </param>
	/// <param name="dict">			the HashSet containing all compatible subsets </param>
	static void subsetSum(int set[], int tup[], int tupLength, int tupMaxSize, int sum, int ite, int target, std::unordered_set<std::vector<int>> &dict);

	/// <summary>
	/// Finds all possible solutions to the subset sum problem
	/// and stores the answer in a HashSet
	/// </summary>
	/// <param name="set"> 			an int array with all the numbers in the set in question </param>
	/// <param name="tup"> 			the int array already included from the set </param>
	/// <param name="tupMaxSize"> 	the length of the tuple  being used currently </param>
	/// <param name="sum">			the current sum of the elements in the tuple </param>
	/// <param name="ite">			set to 0 when calling initially </param>
	/// <param name="target">		the target sum </param>
	/// <param name="dict">			the HashSet containing all compatible subsets </param>
	/*public void analyze(MagicSquareState sq) {
		//sum rows and cols
		int size = sq.n;
		sq.numEmpty = 0;
		for(int i = 0; i < size; i++) {
			for(int j = 0; j < size; j++) {
				sq.sumRow[i] += sq.square[i][j];
				sq.sumCol[i] += sq.square[j][i];
				
				//check if used
				//sq.isUsed[sq.square[i][j]] = true;
				
				//keep count of empty 
				if(sq.square[i][j] == MagicSquare.INITNUM) {
					sq.numEmpty++;
				}
			}
		}
		//sum diag
		for(int i = 0; i < size; i++) {
			sq.sumDiag[0] += sq.square[i][i];
			sq.sumDiag[1] += sq.square[i][size-1-i];
		}
	}*/

	/// <summary>
	/// Finds nearly full rows/columns/diagonals and
	/// fills them in with the correct number
	/// </summary>
	/// <param name="sq"> The MagicSquareState being solved </param>
private:
	void checkZeros(MagicSquareState *sq);

	/// <summary>
	/// Loads a puzzle from the file puzzle.cvs in the working directory
	/// generated by the MagicSquaresGenerator
	/// </summary>
	/// <returns> The MagicSquareState read from the csv file </returns>
	/// <exception cref="FileNotFoundException"> when puzzle.csv cannot be read or opened </exception>
public:
	static MagicSquareState *loadCSV() throw(FileNotFoundException);

};


#endif	//#ifndef GENERALSOLVER
